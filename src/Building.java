import java.util.ArrayList;
import java.util.Timer;
import java.util.TimerTask;

/**
 * @author Oikawa
 *
 * Contains all persons and elevator threads
 *
 * Generates specified number of persons with some interval
 *
 *
 */
public class Building {
    private ArrayList<Floor> floors;
    private ArrayList<Elevator> elevators;
    private ArrayList<Person> persons;
    private Timer personGeneratorTimer;
    private PersonGenerator timerTask;
    //PersonGenerator generator
    //timer that adds peope to list
    EventLogger logger;

    public Building(EventLogger logger, int generatePersonInterval, int limitOfGenerations){
        this.logger = logger;
        floors = new ArrayList<Floor>();
        elevators = new ArrayList<Elevator>();
        persons = new ArrayList<Person>();
        setupPersonGenerator(generatePersonInterval, limitOfGenerations);

    }

    /**
     * Takes copy with mutex lock, so persons ArrayList will not change when taking copy
     * Starts persons threads that added from MainForm(fyi: persons that generated by timer task start to executing in timer)
     * But for now in persons can also be objects generated by timer task, that already running,
     *      so we check if thread already running or not
     */
    public void startupBuildingThreads(){
        timerTask.mtx.lock();
        ArrayList<Person> personsCopy = (ArrayList<Person>)persons.clone();
        timerTask.mtx.unlock();
        for (Person person : personsCopy) {
            if (person.isAlive() == false) {
                person.start();
            }
        }

        for (Elevator elevator : elevators) {
            elevator.start();
        }
    }

    /**
     *
     *  @param generatePersonInterval
     *  @param limitOfGenerations represents how many persons to generate
     */
    public void setupPersonGenerator(int generatePersonInterval, int limitOfGenerations){
        timerTask = new PersonGenerator(this, logger, limitOfGenerations);
        personGeneratorTimer = new Timer();
        personGeneratorTimer.schedule(timerTask, 0, generatePersonInterval);
    }


    /**
     * Waits for all persons and elevators threads
     */
    public void waitForAllThread(){
        while(!timerTask.isEnded()){
            timerTask.mtx.lock();
            ArrayList<Person> personsCopy = (ArrayList<Person>)persons.clone();
            timerTask.mtx.unlock();
            for(int i = 0; i < personsCopy.size(); ++i){
                try{
                    personsCopy.get(i).join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        personGeneratorTimer.cancel();

        // check one more time(some threads may be active for now)
        for (Person person : persons) {
            try{
                person.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        for (Elevator elevator : elevators) {
            try{
                elevator.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void addFloor(Floor floor){
        floors.add(floor);
    }

    public void addElevator(Elevator elevator){
        elevators.add(elevator);
    }

    public void addPerson(Person person){
        persons.add(person);
    }
}
