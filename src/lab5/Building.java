package lab5;

import java.util.ArrayList;
import java.util.Stack;
import java.util.Timer;

/**
 * @author Oikawa
 *
 * Contains all persons and elevator threads
 *
 * Generates specified number of persons with some interval
 *
 *
 */
public class Building implements IBuildingFacade {
    private Stack<Floor> floors;
    private ArrayList<Elevator> elevators;
    private ArrayList<Person> persons;
    private Timer personGeneratorTimer;
    private PersonGenerator timerTask;
    private int generatePersonInterval;

    public Building() {
        floors = new Stack<Floor>();
        elevators = new ArrayList<Elevator>();
        persons = new ArrayList<Person>();
    }

    /**
     * Takes copy with mutex lock, so persons ArrayList will not change when taking copy
     * Starts persons threads that added from MainForm(fyi: persons that generated by timer task start to executing in timer)
     * But for now in persons can also be objects generated by timer task, that already running,
     *      so we check if thread already running or not
     */
    public void startupBuildingThreads(){
        ArrayList<Person> peopleCopy = getPeopleCopyThreadSafe();

        for (Person person : peopleCopy) {
            if (!person.isAlive()) {
                person.start();
            }
        }

        for (Elevator elevator : elevators) {
            elevator.start();
        }

        personGeneratorTimer.schedule(timerTask, 0, generatePersonInterval);
    }

    private ArrayList<Person> getPeopleCopyThreadSafe() {
        timerTask.mtx.lock();
        ArrayList<Person> people = (ArrayList<Person>)persons.clone();
        timerTask.mtx.unlock();
        return people;
    }

    /**
     *
     *  @param generatePersonInterval
     *  @param limitOfGenerations represents how many persons to generate
     */
    public void setupPersonGenerator(int generatePersonInterval, int limitOfGenerations){
        timerTask = new PersonGenerator(this, limitOfGenerations);
        personGeneratorTimer = new Timer();
        this.generatePersonInterval = generatePersonInterval;
    }

    /**
     * Waits for all persons and elevators threads
     */
    public void waitForAllThread(){
        while(!timerTask.isEnded()){
            try{
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        personGeneratorTimer.cancel();

        for (Person person : persons) {
            try {
                person.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // no more work for elevators
        for (Elevator elevator : elevators) {
            elevator.stop();
        }
    }

    public boolean allThreadsEnded(){
        for (Person person : persons) {
            if(person.isAlive()){
                return false;
            }
        }
        for (Elevator elevator : elevators) {
            if(elevator.isAlive()){
                return false;
            }
        }
        return true;
    }

    public void killAllThreads(){
        personGeneratorTimer.cancel();

        for (Person person : persons) {
            person.stop();
        }
        for (Elevator elevator : elevators) {
            elevator.stop();
        }
    }

    public Floor addFloor() {
        int floorNumber = getFloorCount();
        Floor floor = new Floor(floorNumber);
        floors.add(floor);
        return floor;
    }

    public void removeTopFloor() {
        floors.pop();
    }

    public void addElevator(Elevator elevator){
        elevators.add(elevator);
    }

    public void removeElevator(Elevator elevator) {
        elevators.remove(elevator);
    }

    public void addEntrance(int floorNumber, ElevatorEntrance entrance){
        Floor floor = getFloor(floorNumber);
        floor.addEntrance(entrance);
    }

    public void removeEntrance(int floorNumber, ElevatorEntrance entrance) {
        Floor floor = getFloor(floorNumber);
        floor.removeEntrance(entrance);
    }

    public void addPerson(Person person){
        persons.add(person);
    }

    public Floor getFloor(int floorNumber) {
        return floors.get(floorNumber);
    }

    public Elevator getElevator(int elevatorNumber) {
        return elevators.get(elevatorNumber);
    }

    public Floor getUpperFloor(Floor floor){
        if(floor.getNumber() == getFloorCount() - 1){
            throw new Error("There is no upper floor");
        }
        return floors.get(floor.getNumber() + 1);
    }

    public Floor getLowerFloor(Floor floor){
        if(floor.getNumber() == 0){
            throw new Error("There is no lower floor");
        }
        return floors.get(floor.getNumber() - 1);
    }

    @Override
    public int getFloorCount() {
        return floors.size();
    }

    @Override
    public int getElevatorCount() {
        return elevators.size();
    }

    @Override
    public int getPeopleCountOutside(int floorNumber, int elevatorNumber) {
        Floor floor = getFloor(floorNumber);
        Elevator elevator = getElevator(elevatorNumber);
        ElevatorEntrance entrance = floor.getElevatorEntranceByElevator(elevator);
        return entrance.getQueueSize();
    }

    @Override
    public String getElevatorStrategyName(int elevatorNumber) {
        return elevators.get(elevatorNumber).getElevatorStrategy().getName();
    }

    @Override
    public int getPeopleCountInside(int elevatorNumber) {
        Elevator elevator = getElevator(elevatorNumber);
        return elevator.getPeopleInsideCount();
    }

    @Override
    public float getElevatorHeight(int elevatorNumber) {
        Elevator elevator = getElevator(elevatorNumber);
        return elevator.getFloorHeight();
    }

    @Override
    public double getElevatorMass(int elevatorNumber) {
        Elevator elevator = getElevator(elevatorNumber);
        return elevator.getCurrentMass();
    }

    @Override
    public double getElevatorMaxMass(int elevatorNumber) {
        Elevator elevator = getElevator(elevatorNumber);
        return elevator.getMaxMass();
    }

    @Override
    public double getElevatorArea(int elevatorNumber) {
        Elevator elevator = getElevator(elevatorNumber);
        return elevator.getCurrentArea();
    }

    @Override
    public double getElevatorMaxArea(int elevatorNumber) {
        Elevator elevator = getElevator(elevatorNumber);
        return elevator.getMaxArea();
    }

    @Override
    public boolean isElevatorOpen(int elevatorNumber) {
        Elevator elevator = getElevator(elevatorNumber);
        Floor floor = elevator.getCurrentFloor();
        ElevatorEntrance entrance = floor.getElevatorEntranceByElevator(elevator);
        return entrance.isOpen();
    }
}
